### 디자인 패턴 `https://codepump.tistory.com/24?category=672020`

### 제2강 싱글턴(Singleton) 패턴
* 인스턴스가 하나 뿐인 객체를 만들 수 있게 해주는 패턴
* 해당 클래스의 인스턴스가 하나만 생성 됨
* 어디서든 인스턴스에 접근 가능
* 스레드 풀, 캐시, 대화상자, 사용자 설정, 디바이스 드라이버 등 클래스의 객체가 어플리케이션에서 오직 하나만 생성되는 경우 사용
```csharp
namespace SingletonDemo
{
    public sealed class Singleton
    {
        private static int counter = 0;
        private static Singleton instance = null;
        public static Singleton GetInstance
        {
            get
            {
                if (instance == null)
                    instance = new Singleton();
                return instance;
            }
        }
        
        private Singleton()
        {
            counter++;
            Console.WriteLine("Counter Value " + counter.ToString());
        }

        public void PrintDetails(string message)
        {
            Console.WriteLine(message);
        }
    }
}
```

### 제3강 팩토리메소드(Factory Method) 패턴
* 객체를 생성하기 위한 인터페이스를 정의, 어떤 클래스의 인스턴스를 만들지는 파생클래스에서 결정
* 팩토리 메소드는 객체 생성을 처리하며, 팩토리 메소드를 이용하여 객체를 생성하는 작업을 파생클래스에 캡슐화
* 기반클래스에 있는 클라이언트 코드와 파생클래스에 있는 객체 생성 코드를 분리
* 팩토리 메소드에서 파생클래스에 어떤 클래스를 만들지를 결정하게 함으로써 객체 생성을 캡슐화

### 제4강 추상팩토리 패턴
* 객체를 구성하는 부분을 추상화하여 여러 서브클래스가 상속/구현 받아서 객체를 구성
* 객체를 구성하는 클래스들의 생성 공정을 추상화
* 장점 : 객체 생성 과정에 일관성이 있다.
* 단점 : 객체의 구현 내용이 추가 되면 추상 클래스까지 수정해야 한다.

### 제5강 빌더 패턴
* 복학 객체의 생성과정과 표현 방법을 분리하여 통일한 생성절차에서 서로 다른 표현결과를 만들 수 있게 하는 패턴

### 제6강 프로토타입 패턴
* 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 새 객체를 만들기 위해 자기 자신을 복제한다.
* 객체를 생성하는 작업이 매우 클 경우 사용한다.

---
### 제7강 어댑터 패턴
* 클래스의 인터페이스를 사용자가 원하는 다른 인터페이스로 변환하는 디자인 패턴
* 서로 호환성이 없는 클래스들 간의 인터페이스를 생성하여 함께 동작할 수 있도록 한다.

### 제8강 브릿지 패턴
* 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 함
* 클래스의 내용과 클래스에서 처리하는 일이 자주 변화 할 때 유용
* 브릿지 패턴은 종종 클래스 어댑터 패턴을 사용해서 구현되기도 함

### 제9강 컴포지트 패턴
* 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴
* 사용자가 단일 객체와 복합 객체 모두 동일하게 처리 함
* 사용 방법
    * 객체의 구성 및 상하위 체계를 파악
    * 파악된 객체들을 트리 구조로 설계
    * 객체와 복합객체는 공통으로 사용할 수 있는 메소드가 정의된 인터페이스/추상클래스를 구현/상속

### 제10강 데코레이터 패턴
* 상황 및 용도에 따라 객체에 필요한 요소들을 동적으로 추가한다.
* 기능 확장이 필요할 경우 클래스를 상속하는 대신 유연하게 사용할 수 있다.
* 하나의 객체를 여러 개의 데코레이터를 추가할 수 있다.
* 장점
    * 기존 코드를 수정하지 않고도 확장할 수 있다.
* 단점
    * 클래스의 종류가 많아지고 객체를 파악하기 어려워진다.

### 제11강 퍼사드(Facade) 패턴
* 클래스 라이브러리 같은 커다란 코드를 사용하기 위한 간략한 인터페이스를 제공
* 라이브러리 외부 코드가 라이브러리의 안쪽 코드에 의존하는 일을 감소시킨다.
* 소프트웨어 라이브러리를 쉽게 이해할 수 있게 해 준다.
* 대부분의 외부 코드에서 퍼사드를 이용하기 때문에 시스템을 개발하는 데 있어 유연성이 향상된다.

### 제12강 프록시 패턴(Proxy Pattern)
* 대리자로써 작업 수행을 요청하면 처리 후 그 결과를 알려주는 패턴
* 클래스안에 처리과정이 복잡하고 리소스를 많이 차지할 경우 클래스를 생성하여 처리
* 접근 제한을 둘 수 있기 때문에 원격 제어 프로그램 작성 시에도 유용
* 네트워크 연결, 메모리의 객체, 복제할 수 업거나 자주 사용되는 리소스 등의 인터페이스 등에 사용

---
### 제13강 커맨드 패턴
* 특정 객체에 대한 특정 작업 요청을 캡슐화
* 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴
* 요청과 수행을 분리
* 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메소드를 수행

### 제14강 이터레이터(Iterator) 패턴(=반복자 패턴)
* 객체 집합의 내용을 노출시키지 않고 집합의 원소들을 모든 항목에 순차적으로 접근할 수 있는 방법을 제공
* 개체 내부의 표현 방식을 알 필요 없이 집합의 각 원소들에 접근하고 싶을 때 사용
* 서로 다른 구조의 객체 집합을 동일한 방식으로 순차 접근하고 싶을 때 사용

### 제15강 미디에이터 패턴
* 클래스간의 복잡한 로직을 하나의 클래스(중재자)에 위임하여 처리
* 클래스 간 인터페이스의 복잡도를 떨어뜨릴 목적으로 사용
* 클래스 간의 복잡도를 떨어뜨려 유지 보수 및 재사용, 확장등에 유리하다.

### 제16강 옵저버 패턴
* 객체의 상황 변화를 관찰하는 관찰자(옵저버)들의 목록을 객체에 등록하여 상태변화가 있을 때 마다 메소드를 통해 객체가 직접 관찰자들에 통지하는 패턴
* 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 자동으로 전달
* 일대 다 의존성을 정의
* 분산 이벤트 핸들링 시스템 구현에 이용

### 제17강 전략(Strategy) 패턴
* 알고리즘 군을 정의하고 각각을 캡슐화하여 교환하며 사용 할 수 있도록 만드는 패턴
* 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘의 변경이 가능
* 결과를 만드는 메소드는 동일하나 그 목적을 달성하는 방법이 여러가지가 존재할 경우 사용